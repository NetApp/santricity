#!/usr/bin/python

# (c) 2020, NetApp, Inc
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type


DOCUMENTATION = """
module: na_santricity_server_certificate
short_description: NetApp E-Series manage the storage system's server SSL certificates.
description: Manage NetApp E-Series storage system's server SSL certificates.
author: Nathan Swartz (@ndswartz)
extends_documentation_fragment:
    - netapp_eseries.santricity.santricity.santricity_doc
options:
  state:
    description:
      - Whether certificates should be present or absent from the storage system's certificate database.
    type: str
    choices:
      - present
      - absent
    default: present
  controller:
    description:
      - The controller that owns the port you want to configure.
      - Controller names are represented alphabetically, with the first controller as A, the second as B, and so on.
      - Current hardware models have either 1 or 2 available controllers, but that is not a guaranteed hard limitation and could change in the future.
    choices:
        - A
        - B
    type: str
    required: true
  authoritative_certs:
    description:
      - List of CA authorities certificates.
      - Be sure not to include the server's certificate. If you have a bundle that includes the server certificate provide the path to I(public_cert).
    type: list
    required: false
  public_cert:
    description:
      - File path to a signed SSL certificate or bundle.
      - Required when I(private_key) is specified.
      - Do not specify I(private_key) when a bundle is provided that includes the private key.
      - Mutually exclusive when I(state=='absent') since a public SSL certificate must exist.
    type: str
    required: false
  private_key:
    description:
      - File path to the main storage system's SSL certificate private key.
      - Required when I(public_certs) is specified and the certificate's CSR was not generated by the E-Series storage system.
      - Mutually exclusive when I(state==absent) since a private key must exist.
    type: str
    required: false
  use_self_signed_cert:
    description:
      - Whether to use the self-signed certificate generated by the E-Series storage system.
      - Mutually exclusive with I(public_cert) and I(private_key).
    type: bool
    default: false
    required: false
notes:
  - Set I(ssid=="0") or I(ssid=="proxy") to specifically reference SANtricity Web Services Proxy.
  - SSL certificates can be the following filetypes: PEM (.pem, .crt, .cer, or .key) or DER (.der or .cer)
  - All authoritative certificates will be parsed individually in the case of PEM chained bundles.
  - All authoritative certificates will be aliased using the certificate's fingerprint. 
requirements:
  - cryptography
"""
EXAMPLES = """
- name: Ensure SSL certificate has been installed.
  na_santricity_server_certificate:
    ssid: 1
    api_url: https://192.168.1.100:8443/devmgr/v2
    api_username: admin
    api_password: adminpass
    authoritative_certs:
      - "root_auth_ssl_cert.pem"
      - "intermediate_auth1_ssl_cert.crt"
      - "intermediate_auth2_ssl_cert.crt"
    public_cert: "public_ssl_cert.pem"
    private_key: "private_key.pem"
- name: Ensure SSL certificate bundle has been installed.
  na_santricity_server_certificate:
    ssid: 1
    api_url: https://192.168.1.100:8443/devmgr/v2
    api_username: admin
    api_password: adminpass
    public_cert: "public_ssl_cert_bundle.pem"
    private_key: "private_key.pem"
- name: Ensure old SSL certificates have been uninstalled.
  na_santricity_server_certificate:
    ssid: 1
    api_url: https://192.168.1.100:8443/devmgr/v2
    api_username: admin
    api_password: adminpass
    state: absent
    authoritative_certs:
      - "old_root_auth_ssl_cert.crt"
      - "old_intermediate_auth1_ssl_cert.crt"
      - "old_intermediate_auth2_ssl_cert.crt"
- name: Ensure storage system is using a self-signed certificate.
  na_santricity_server_certificate:
    ssid: 1
    api_url: https://192.168.1.100:8443/devmgr/v2
    api_username: admin
    api_password: adminpass
    use_self_signed_cert: true
"""
RETURN = """
changed:
    description: Whether changes have been made.
    type: bool
    returned: always
    sample: true
signed_server_certificate:
    description: Whether the public server certificate is signed.
    returned: always
    sample: true
added_certificates:
    description: Any SSL certificates that were added.
    type: list
    returned: always
    sample: ["added_cerificiate.crt"]
removed_certificates:
    description: Any SSL certificates that were removed.
    type: list
    returned: always
    sample: ["removed_cerificiate.crt"]
"""

import binascii
import os
import random
import re

from time import sleep
from ansible.module_utils import six
from ansible_collections.netapp_eseries.santricity.plugins.module_utils.santricity import NetAppESeriesModule
from ansible.module_utils._text import to_native

try:
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
except ImportError:
    HAS_CRYPTOGRAPHY = False
else:
    HAS_CRYPTOGRAPHY = True


def create_multipart_formdata(certificate):
    """Create the data for a multipart/form request for a certificate."""
    boundary = "---------------------------" + "".join([str(random.randint(0, 9)) for x in range(30)])
    data_parts = list()
    data = None

    if six.PY2:  # Generate payload for Python 2
        newline = "\r\n"
        for name, filename, content in certificate:
            data_parts.extend(["--%s" % boundary,
                               'Content-Disposition: form-data; name="%s"; filename="%s"' % (name, filename),
                               "Content-Type: application/octet-stream",
                               "",
                               content])
        data_parts.extend(["--%s--" % boundary, ""])
        data = newline.join(data_parts)

    else:
        newline = six.b("\r\n")
        for name, filename, content in certificate:
            data_parts.extend([six.b("--%s" % boundary),
                               six.b('Content-Disposition: form-data; name="%s"; filename="%s"' % (name, filename)),
                               six.b("Content-Type: application/octet-stream"),
                               six.b(""),
                               content])
        data_parts.extend([six.b("--%s--" % boundary), b""])
        data = newline.join(data_parts)

    headers = {
        "Content-Type": "multipart/form-data; boundary=%s" % boundary,
        "Content-Length": str(len(data))}

    return headers, data


class NetAppESeriesServerCertificate(NetAppESeriesModule):
    RESET_SSL_CONFIG_TIMEOUT_SEC = 3 * 60

    def __init__(self):
        ansible_options = dict(state=dict(type="str", default="present", choices=["present", "absent"], required=False),
                               controller=dict(type="str", required=True, choices=["A", "B"]),
                               authoritative_certs=dict(type="list", required=False),
                               public_cert=dict(type="str", require=False),
                               private_key=dict(type="str", required=False),
                               use_self_signed_cert=dict(type="bool", default=False, required=False))
        mutually_exclusive = [["public_cert", "use_self_signed_cert"],
                              ["private_key", "use_self_signed_cert"]]
        super(NetAppESeriesServerCertificate, self).__init__(ansible_options=ansible_options,
                                                             web_services_version="05.00.0000.0000",
                                                             mutually_exclusive=mutually_exclusive,
                                                             supports_check_mode=True)

        args = self.module.params
        self.state = args["state"]
        self.controller = args["controller"]
        self.use_self_signed_cert = args["use_self_signed_cert"]
        self.authoritative_certs = args["authoritative_certs"] if "authoritative_certs" in args.keys() else {}
        self.public_cert = args["public_cert"] if "public_cert" in args.keys() else None
        self.private_key = args["private_key"] if "private_key" in args.keys() else None

        # Check whether request needs to be forwarded on to the controller web services rest api.
        self.url_path_prefix = ""
        if self.is_proxy() and self.ssid != "0" and self.ssid != "PROXY":
            self.url_path_prefix = "storage-systems/%s/forward/devmgr/v2/" % self.ssid

        self.cache_get_current_certificates = None
        self.cache_is_controller_alternate = None
        self.cache_is_public_server_certificate_signed = None

        self.private_key_file_content = None

        # Class members indicating changes required.
        self.unsigned_cert = False
        self.signed_cert = None
        self.add_authorities = list()
        self.remove_authorities = list()

    def get_controllers(self):
        """Retrieve a mapping of controller labels to their controller slot."""
        controllers_dict = {}
        controllers = []
        try:
            rc, controllers = self.request("storage-systems/%s/controllers" % self.ssid)
        except Exception as error:
            self.module.fail_json(msg="Failed to retrieve the controller settings. Array Id [%s]. Error [%s]." % (self.ssid, to_native(error)))

        for controller in controllers:
            slot = controller['physicalLocation']['slot']
            letter = chr(slot + 64)
            controllers_dict.update({letter: slot})

        return controllers_dict

    def is_controller_alternate(self):
        """Is the effected controller the alternate controller."""
        if self.cache_is_controller_alternate is None:
            controllers_info = self.get_controllers()
            try:
                rc, about = self.request("utils/about", rest_api_path=self.DEFAULT_BASE_PATH)
                self.cache_is_controller_alternate = controllers_info[self.controller] != about["controllerPosition"]
            except Exception as error:
                self.module.fail_json(msg="Failed to retrieve accessing controller slot information. Array [%s]." % self.ssid)

        return self.cache_is_controller_alternate

    @staticmethod
    def sanitize_distinguished_name(dn):
        """Generate a sorted distinguished name string to account for different formats/orders."""
        dn = re.sub(" *= *", "=", dn).lower()
        dn = re.sub(", *(?=[a-zA-Z]+={1})", "---SPLIT_MARK---", dn)
        dn_parts = dn.split("---SPLIT_MARK---")
        dn_parts.sort()
        return ",".join(dn_parts)

    def certificate_info_from_file(self, path):
        """Determine the certificate info from the provided filepath."""
        certificates_info = {}
        with open(path, "r") as fh:
            line = fh.readline()
            while line != "":

                # Add public certificates to bundle_info.
                if re.search("^-+BEGIN CERTIFICATE-+$", line):
                    certificate = line
                    line = fh.readline()
                    while not re.search("^-+END CERTIFICATE-+$", line):
                        if line == "":
                            self.module.fail_json(msg="Invalid certificate! Array [%s]." % self.ssid)
                        certificate += line
                        line = fh.readline()
                    certificate += line
                    certificates_info.update(self.certificate_info(certificate))

                # Add private key to self.private_key.
                elif re.search("^-+BEGIN.*PRIVATE KEY-+$", line):
                    key = line
                    line = fh.readline()
                    while not re.search("^-+END.*PRIVATE KEY-+$", line):
                        if line == "":
                            self.module.fail_json(msg="Invalid certificate! Array [%s]." % self.ssid)
                        key += line
                        line = fh.readline()
                    key += line

                    if self.private_key_file_content is not None and self.private_key_file_content != key:
                        self.module.fail_json(msg="Multiple private keys have been provided! Array [%s]" % self.ssid)
                    else:
                        self.private_key_file_content = key

                line = fh.readline()

        # Check for DER format (DER format can only have a single certificate or private key)
        #   DER is the parent of PEM, that is PEM is a base64 encoded DER file wrapped in the --BEGIN X--/--END X-- lines
        if len(certificates_info) == 0:
            with open(path, "r") as fh:
                certificates_info.update(self.certificate_info(fh.read()))

        return certificates_info

    def certificate_info(self, data):
        """Load x509 certificate that is either encoded DER or PEM encoding and return the certificate fingerprint."""
        info = None
        try:
            info = x509.load_pem_x509_certificate(data, default_backend())
        except Exception as error:
            try:
                info = x509.load_der_x509_certificate(data, default_backend())
            except Exception as error:
                self.module.fail_json(msg="Failed to determine certificate info. Data [%s]. Array [%s]. Error [%s]." % (data, self.ssid, to_native(error)))

        fingerprint = binascii.hexlify(info.fingerprint(info.signature_hash_algorithm)).decode("utf-8")
        return {self.sanitize_distinguished_name(info.subject.rfc4514_string()): {"alias": fingerprint, "fingerprint": fingerprint, "certificate": data,
                                                                                  "issuer": self.sanitize_distinguished_name(info.issuer.rfc4514_string())}}

    def get_current_certificates(self):
        """Determine the server certificates that exist on the storage system."""
        if self.cache_get_current_certificates is None:
            current_certificates = []
            for retry in range(int(self.RESET_SSL_CONFIG_TIMEOUT_SEC / 3)):
                try:
                    rc, current_certificates = self.request("certificates/server?alternate=%s" % ("true" if self.is_controller_alternate() else "false"))
                except Exception as error:
                    continue
                break
            else:
                self.module.fail_json(msg="Failed to retrieve server certificates. Array [%s]." % self.ssid)

            self.cache_get_current_certificates = {}
            for certificate in current_certificates:
                certificate.update({"issuer": self.sanitize_distinguished_name(certificate["issuerDN"])})
                self.cache_get_current_certificates.update({self.sanitize_distinguished_name(certificate["subjectDN"]): certificate })

        return self.cache_get_current_certificates

    def is_public_server_certificate_signed(self):
        """Return whether the public server certificate is signed."""
        if self.cache_is_public_server_certificate_signed is None:
            current_certificates = self.get_current_certificates()

            for certificate in current_certificates:
                if current_certificates[certificate]["alias"] == "jetty":
                    self.cache_is_public_server_certificate_signed = current_certificates[certificate]["type"] == "caSigned"
                    break

        return self.cache_is_public_server_certificate_signed

    def get_effected_certificates(self):
        """Determine effected certificates and return certificate list in the required submission order."""
        effected = {"authoritative_certs": [], "public_cert": None, "private_key": None}
        certificates_info = {}
        existing_certificates = self.get_current_certificates()

        # Determine all certificates include in self.public_cert which can be PEM or DER
        if self.public_cert:
            certificates_info.update(self.certificate_info_from_file(self.public_cert))

        # Add all other authoritative certificates.
        if self.authoritative_certs:
            for path in self.authoritative_certs:
                certificates_info.update(self.certificate_info_from_file(path))

        # Determine bundle certificate ordering.
        ordered_certificates_info = [None] * len(certificates_info)
        ordered_certificates_info_index = len(certificates_info) - 1
        while certificates_info:
            for certificate_subject in certificates_info.keys():

                # Search for the next certificate that is not an issuer of the remaining certificates in certificates_info.
                if certificate_subject not in [cert["issuer"] for cert in certificates_info.values() + existing_certificates.values()]:
                    ordered_certificates_info[ordered_certificates_info_index] = certificates_info[certificate_subject]
                    certificates_info.pop(certificate_subject)
                    ordered_certificates_info_index -= 1
                    break
            else:  # If there are any here then the certificate was not issued by another. Just place them at the beginning. This will include self-signed.
                for certificate_subject in certificates_info.keys():
                    ordered_certificates_info[ordered_certificates_info_index] = certificates_info[certificate_subject]
                    ordered_certificates_info_index -= 1
                break

        if self.public_cert is not None:
            effected["public_cert"] = ordered_certificates_info[-1]
            effected["public_cert"]["alias"] = "jetty"
            effected["authoritative_certs"] = ordered_certificates_info[:-1]
        else:
            effected["authoritative_certs"] = ordered_certificates_info

        if self.private_key_file_content is not None:
            effected["private_key"] = self.private_key_file_content

        if self.private_key is not None:
            with open(self.private_key, "r") as fh:
                key = fh.read()
            if effected["private_key"] is not None:
                if key != effected["private_key"]:
                    self.module.fail_json(msg="Multiple private keys have been provided that do not match! Be aware that certificate bundles can include"
                                              " private keys. Array [%s]." % self.ssid)
            else:
                effected["private_key"] = key

        return effected

    def determine_changes(self):
        """Determine certificates that need to be added or removed from storage system's server certificates database."""
        change_required = False
        effected_certificates = self.get_effected_certificates()
        existing_certificates = self.get_current_certificates()

        if self.state == "present":
            # Determine whether changes are required for authoritative certificates.
            for effected_certificate in effected_certificates["authoritative_certs"]:
                for existing_certificate_issuer, existing_certificate in existing_certificates.items():
                    if effected_certificate["alias"] == existing_certificate["alias"]:
                        if (effected_certificate["fingerprint"] != existing_certificate["shaFingerprint"] and
                                effected_certificate["fingerprint"] != existing_certificate["sha256Fingerprint"]):
                            self.add_authorities.append(effected_certificate)
                            change_required = True
                        break
                else:
                    self.add_authorities.append(effected_certificate)
                    change_required = True

            # Determine whether changes are required for public server certificate.
            if effected_certificates["public_cert"] is not None:
                for existing_certificate_issuer, existing_certificate in existing_certificates.items():
                    if (existing_certificate["alias"] == "jetty" and
                            (effected_certificates["public_cert"]["fingerprint"] != existing_certificate["shaFingerprint"] and
                             effected_certificates["public_cert"]["fingerprint"] != existing_certificate["sha256Fingerprint"])):
                        self.signed_cert = {"public_cert": effected_certificates["public_cert"], "private_key": effected_certificates["private_key"]}
                        change_required = True
                        break

        else:
            for effected_certificate in effected_certificates["authoritative_certs"]:
                for existing_certificate_issuer, existing_certificate in existing_certificates.items():
                    if effected_certificate["alias"] == existing_certificate["alias"]:
                        self.remove_authorities.append(effected_certificate["alias"])
                        change_required = True
                        break

        if self.use_self_signed_cert and self.is_public_server_certificate_signed():
            self.unsigned_cert = True
            change_required = True

        return change_required

    def self_signed_certificate(self):
        """Install self-signed server certificate which is generated by the storage system itself."""
        try:
            rc, resp = self.request("certificates/reset?alternate=%s" % ("true" if self.is_controller_alternate() else "false"), method="POST")
        except Exception as error:
            self.module.fail_json(msg="Failed to reset SSL configuration back to a self-signed certificate! Array [%s]. Error [%s]." % (self.ssid, error))

    def signed_certificate(self):
        """Install authoritative signed server certificate whether csr is generated by storage system or not."""
        headers, data = create_multipart_formdata([["file", "signed_server_certificate", self.signed_cert["public_cert"]["certificate"]],
                                                   ["privateKey", "private_key", self.signed_cert["private_key"]]])
        try:
            rc, res = self.request("certificates/server?alternate=%s&replaceMainServerCertificate=true"
                                   % ("true" if self.is_controller_alternate() else "false"), method="POST", headers=headers, data=data)
        except Exception as error:
            self.module.fail_json(msg="Failed to upload signed server certificate! Array [%s]. Error [%s]." % (self.ssid, error))

    def upload_authoritative_certificates(self):
        """Install all authoritative certificates."""
        for certificate in self.add_authorities:
            headers, data = create_multipart_formdata([["file", certificate["alias"], certificate["certificate"]]])
            try:
                rc, resp = self.request("certificates/server?alternate=%s&alias=%s" % (("true" if self.is_controller_alternate() else "false"),
                                                                                       certificate["alias"]), method="POST", headers=headers, data=data)
                # rc, resp = self.request("certificates/server?alternate=true&alias=%s" % certificate["alias"], method="POST", headers=headers, data=data)
                # rc, resp = self.request("certificates/server?alternate=false&alias=%s" % certificate["alias"], method="POST", headers=headers, data=data)
            except Exception as error:
                self.module.fail_json(msg="Failed to upload certificate authority! Array [%s]. Error [%s]." % (self.ssid, error))

    def delete_authoritative_certificates(self):
        """Delete all authoritative certificates."""
        for alias in self.remove_authorities:
            try:
                rc, resp = self.request("certificates/server/%s?alternate=%s" % (alias, "true" if self.is_controller_alternate() else "false"), method="DELETE")
            except Exception as error:
                self.module.fail_json(msg="Failed to delete certificate authority! Array [%s]. Error [%s]." % (self.ssid, error))

    def reload_ssl_configuration(self):
        """Asynchronously reloads the SSL configuration."""
        self.cache_get_current_certificates = None
        self.cache_is_public_server_certificate_signed = None
        self.request("certificates/reload?alternate=%s&reloadBoth=false" % ("true" if self.is_controller_alternate() else "false"),
                     method="POST", ignore_errors=True)
        self.is_public_server_certificate_signed()

    def apply(self):
        """Apply state changes to the storage array's truststore."""
        change_required = self.determine_changes()

        if change_required and not self.module.check_mode:
            if self.add_authorities:
                self.upload_authoritative_certificates()
            elif self.remove_authorities:
                self.delete_authoritative_certificates()

            if self.unsigned_cert:
                self.self_signed_certificate()
                self.reload_ssl_configuration()
            elif self.signed_cert:
                self.signed_certificate()
                self.reload_ssl_configuration()

        self.module.exit_json(changed=change_required, signed_server_certificate=self.is_public_server_certificate_signed(),
                              added_certificates=[cert["alias"] for cert in self.add_authorities],
                              removed_certificates=self.remove_authorities)


def main():
    client_certs = NetAppESeriesServerCertificate()
    client_certs.apply()


if __name__ == "__main__":
    main()
